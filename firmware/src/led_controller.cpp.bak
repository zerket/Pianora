#include "led_controller.h"

// Global pointer - initialized in setup() to avoid static initialization issues
LEDController* ledController = nullptr;

LEDController::LEDController()
    : _enabled(true)
    , _mode(MODE_FREE_PLAY)
    , _brightness(128)
    , _hue(0)
    , _saturation(255)  // Revert to original value
    , _fadeRate(15)
    , _splitPosition(44)  // Middle of keyboard
    , _leftColor(0, 255, 255)    // Red
    , _rightColor(160, 255, 255) // Cyan
    , _randomHue(0)
    , _expectedCount(0)
    , _guideColor(42, 255, 255)   // Golden yellow (hue 42)
    , _successColor(96, 255, 255) // Green (hue 96)
    , _errorColor(0, 255, 255)    // Red (hue 0)
    , _bgEnabled(false)
    , _bgColor(160, 255, 32)      // Dim cyan background
    , _bgBrightness(32)
    , _hueShiftEnabled(false)
    , _hueShiftAmount(10)         // Shift hue by 10 per chord note
    , _chordWindowMs(600)         // 600ms chord detection window
    , _lastNoteTime(0)
    , _currentChordHue(160)       // Start with base hue
    , _splashEnabled(false)
    , _lastFadeTime(0)
    , _ambientAnimation(0)     // Default: Rainbow
    , _animationSpeed(50)      // Medium speed
    , _animationOffset(0)
{
    memset(_keysOn, 0, sizeof(_keysOn));
    memset(_keyVelocity, 0, sizeof(_keyVelocity));
    memset(_keyHue, 0, sizeof(_keyHue));
    memset(_expectedNotes, 0, sizeof(_expectedNotes));
    memset(_splashes, 0, sizeof(_splashes));
}

void LEDController::begin() {
    // Initialize FastLED
    FastLED.addLeds<WS2812B, LED_PIN, GRB>(_leds, NUM_LEDS);
    FastLED.setBrightness(_brightness);
    FastLED.setMaxPowerInVoltsAndMilliamps(5, LED_MAX_POWER_MW);

    // Start with all LEDs off
    blackout();
}

void LEDController::update() {
    unsigned long now = millis();

    // Fade effect
    if (now - _lastFadeTime >= FADE_INTERVAL) {
        _lastFadeTime = now;

        // Handle ambient mode animations
        if (_mode == MODE_AMBIENT) {
            updateAmbient();
        } else {
            fade();

            // Update splash effects if enabled
            if (_splashEnabled) {
                updateSplash();
            }

            // In learning mode, show guide color for expected notes that aren't pressed
            if (_mode == MODE_LEARNING && _expectedCount > 0) {
                for (uint8_t i = 0; i < _expectedCount; i++) {
                    uint8_t midiNote = _expectedNotes[i];
                    if (midiNote >= LOWEST_MIDI_NOTE && midiNote <= HIGHEST_MIDI_NOTE) {
                        uint8_t keyIndex = midiNote - LOWEST_MIDI_NOTE;
                        // Only show guide if key is not currently pressed
                        if (!_keysOn[keyIndex]) {
                            setKeyLEDs(keyIndex, CHSV(_guideColor.h, _guideColor.s, _guideColor.v));
                        }
                    }
                }
            }
        }

        FastLED.show();
    }
}

void LEDController::noteOn(uint8_t note, uint8_t velocity) {
    if (!_enabled) return;  // Skip if LEDs are disabled
    if (note < LOWEST_MIDI_NOTE || note > HIGHEST_MIDI_NOTE) return;
    if (velocity == 0) {
        noteOff(note);
        return;
    }

    uint8_t keyIndex = mapNoteToKeyIndex(note);
    _keysOn[keyIndex] = true;
    _keyVelocity[keyIndex] = velocity;

    // Chord detection for hue shift
    if (_hueShiftEnabled) {
        unsigned long now = millis();
        if (now - _lastNoteTime < _chordWindowMs) {
            // Same chord - shift hue
            _currentChordHue = (_currentChordHue + _hueShiftAmount) % 256;
        } else {
            // New chord - reset to base hue
            _currentChordHue = _hue;
        }
        _lastNoteTime = now;
        // Store the chord hue for this key
        _keyHue[keyIndex] = _currentChordHue;
    }

    // For random mode, assign new random hue on each note
    if (_mode == MODE_RANDOM) {
        _keyHue[keyIndex] = random(256);
    }

    CRGB color = getColorForKey(keyIndex, velocity);
    setKeyLEDs(keyIndex, color);

    // Add splash effect if enabled
    if (_splashEnabled) {
        addSplash(keyIndex, velocity);
    }

    FastLED.show();
}

void LEDController::noteOff(uint8_t note) {
    if (note < LOWEST_MIDI_NOTE || note > HIGHEST_MIDI_NOTE) return;

    uint8_t keyIndex = mapNoteToKeyIndex(note);
    _keysOn[keyIndex] = false;
    _keyVelocity[keyIndex] = 0;
    // LEDs will fade out naturally via fade()
}

void LEDController::allNotesOff() {
    memset(_keysOn, 0, sizeof(_keysOn));
    memset(_keyVelocity, 0, sizeof(_keyVelocity));
    blackout();
}

void LEDController::setMode(LEDMode mode) {
    _mode = mode;
    // When changing to random mode, pick a new random hue
    if (_mode == MODE_RANDOM) {
        _randomHue = random(256);
    }
}

LEDMode LEDController::getMode() const {
    return _mode;
}

void LEDController::setBrightness(uint8_t brightness) {
    _brightness = brightness;
    FastLED.setBrightness(_brightness);
}

uint8_t LEDController::getBrightness() const {
    return _brightness;
}

void LEDController::setHue(uint8_t hue) {
    _hue = hue;
}

uint8_t LEDController::getHue() const {
    return _hue;
}

void LEDController::setSaturation(uint8_t saturation) {
    _saturation = saturation;
}

void LEDController::setFadeRate(uint8_t rate) {
    _fadeRate = rate;
}

void LEDController::setSplitPosition(uint8_t position) {
    if (position < NUM_PIANO_KEYS) {
        _splitPosition = position;
    }
}

void LEDController::setLeftColor(uint8_t hue, uint8_t sat, uint8_t val) {
    _leftColor = CHSV(hue, sat, val);
}

void LEDController::setRightColor(uint8_t hue, uint8_t sat, uint8_t val) {
    _rightColor = CHSV(hue, sat, val);
}

void LEDController::blackout() {
    fill_solid(_leds, NUM_LEDS, CRGB::Black);
    FastLED.show();
}

void LEDController::showColor(CRGB color) {
    fill_solid(_leds, NUM_LEDS, color);
    FastLED.show();
}

void LEDController::playStartupAnimation() {
    // Rainbow wave animation (туда-обратно, один раз)
    const uint8_t WAVE_WIDTH = 20;  // Width of the wave
    const uint8_t ANIMATION_DELAY = 8;  // Speed of animation

    // Wave going right
    for (int16_t pos = -WAVE_WIDTH; pos <= NUM_LEDS; pos++) {
        fill_solid(_leds, NUM_LEDS, CRGB::Black);

        for (int16_t i = 0; i < WAVE_WIDTH; i++) {
            int16_t ledIndex = pos + i;
            if (ledIndex >= 0 && ledIndex < NUM_LEDS) {
                // Rainbow gradient within the wave
                uint8_t hue = (i * 256 / WAVE_WIDTH);
                uint8_t brightness = sin8((i * 255) / WAVE_WIDTH);  // Fade at edges
                _leds[ledIndex] = CHSV(hue, 255, brightness);
            }
        }
        FastLED.show();
        delay(ANIMATION_DELAY);
        yield();  // Feed watchdog to prevent reset
    }

    // Wave going left
    for (int16_t pos = NUM_LEDS; pos >= -WAVE_WIDTH; pos--) {
        fill_solid(_leds, NUM_LEDS, CRGB::Black);

        for (int16_t i = 0; i < WAVE_WIDTH; i++) {
            int16_t ledIndex = pos + i;
            if (ledIndex >= 0 && ledIndex < NUM_LEDS) {
                // Rainbow gradient within the wave
                uint8_t hue = (i * 256 / WAVE_WIDTH);
                uint8_t brightness = sin8((i * 255) / WAVE_WIDTH);
                _leds[ledIndex] = CHSV(hue, 255, brightness);
            }
        }
        FastLED.show();
        delay(ANIMATION_DELAY);
        yield();  // Feed watchdog to prevent reset
    }

    // End with all LEDs off
    blackout();
}

// ============== Private Methods ==============

uint8_t LEDController::mapNoteToKeyIndex(uint8_t midiNote) {
    // Map MIDI note 21-108 to key index 0-87
    if (midiNote < LOWEST_MIDI_NOTE) return 0;
    if (midiNote > HIGHEST_MIDI_NOTE) return NUM_PIANO_KEYS - 1;
    return midiNote - LOWEST_MIDI_NOTE;
}

void LEDController::setKeyLEDs(uint8_t keyIndex, CRGB color) {
    if (keyIndex >= NUM_PIANO_KEYS) return;

    // Each key has LEDS_PER_KEY LEDs
    uint16_t startLED = keyIndex * LEDS_PER_KEY;
    for (uint8_t i = 0; i < LEDS_PER_KEY; i++) {
        if (startLED + i < NUM_LEDS) {
            _leds[startLED + i] = color;
        }
    }
}

CRGB LEDController::getColorForKey(uint8_t keyIndex, uint8_t velocity) {
    uint8_t h, s, v;

    switch (_mode) {
        case MODE_FREE_PLAY:
            // Fixed color from settings, or shifted hue if hue shift is enabled
            h = _hueShiftEnabled ? _keyHue[keyIndex] : _hue;
            s = _saturation;
            v = 255;
            break;

        case MODE_VELOCITY:
            // Map velocity to color: soft=green(96), hard=red(0)
            h = map(velocity, 1, 127, 96, 0);
            s = 255;
            v = map(velocity, 1, 127, 128, 255);
            break;

        case MODE_SPLIT:
            // Left or right color based on position
            if (keyIndex < _splitPosition) {
                return CHSV(_leftColor.h, _leftColor.s, _leftColor.v);
            } else {
                return CHSV(_rightColor.h, _rightColor.s, _rightColor.v);
            }

        case MODE_RANDOM:
            // Use stored random hue for this key
            h = _keyHue[keyIndex];
            s = 255;
            v = 255;
            break;

        case MODE_VISUALIZER:
            // Rainbow based on key position
            h = map(keyIndex, 0, NUM_PIANO_KEYS - 1, 0, 255);
            s = 255;
            v = 255;
            break;

        case MODE_LEARNING: {
            // Check if this key is in expected notes
            uint8_t midiNote = keyIndex + LOWEST_MIDI_NOTE;
            bool isExpected = false;
            for (uint8_t i = 0; i < _expectedCount; i++) {
                if (_expectedNotes[i] == midiNote) {
                    isExpected = true;
                    break;
                }
            }

            if (isExpected) {
                // Correct note pressed - show success color
                return CHSV(_successColor.h, _successColor.s, _successColor.v);
            } else {
                // Wrong note pressed - show error color
                return CHSV(_errorColor.h, _errorColor.s, _errorColor.v);
            }
        }

        case MODE_KIDS_RAINBOW: {
            // Kids Rainbow mode: each octave gets a different color
            // MIDI note 21 (A0) = octave 0, note 33 (A1) = octave 1, etc.
            uint8_t midiNote = keyIndex + LOWEST_MIDI_NOTE;
            uint8_t octave = (midiNote - 12) / 12;  // C-based octave (C4 = octave 4)

            // Rainbow colors by octave (7 octaves on 88-key piano)
            // 0-1: Red, 2: Orange, 3: Yellow, 4: Green, 5: Cyan, 6: Blue, 7+: Purple
            const uint8_t octaveHues[] = {0, 0, 32, 64, 96, 128, 160, 192};
            uint8_t octaveIndex = min(octave, (uint8_t)7);
            h = octaveHues[octaveIndex];
            s = 255;
            v = 255;
            break;
        }

        default:
            h = _hue;
            s = _saturation;
            v = 255;
            break;
    }

    return CHSV(h, s, v);
}

void LEDController::fade() {
    // Only fade LEDs for keys that are not pressed
    CRGB targetColor = CRGB::Black;
    if (_bgEnabled) {
        // Fade toward background color instead of black
        targetColor = CHSV(_bgColor.h, _bgColor.s, _bgBrightness);
    }

    for (uint8_t key = 0; key < NUM_PIANO_KEYS; key++) {
        if (!_keysOn[key]) {
            uint16_t startLED = key * LEDS_PER_KEY;
            for (uint8_t i = 0; i < LEDS_PER_KEY; i++) {
                if (startLED + i < NUM_LEDS) {
                    if (_bgEnabled) {
                        // Blend toward background color
                        _leds[startLED + i] = nblend(_leds[startLED + i], targetColor, _fadeRate);
                    } else {
                        _leds[startLED + i].fadeToBlackBy(_fadeRate);
                    }
                }
            }
        }
    }
}

// ============== Splash Effect ==============

void LEDController::setSplashEnabled(bool enabled) {
    _splashEnabled = enabled;
    // Clear all splashes when disabling
    if (!enabled) {
        memset(_splashes, 0, sizeof(_splashes));
    }
}

bool LEDController::isSplashEnabled() const {
    return _splashEnabled;
}

uint8_t LEDController::velocityToSplashWidth(uint8_t velocity) {
    // Soft (1-42) = 3 LEDs, Medium (43-84) = 4 LEDs, Hard (85-127) = 6 LEDs
    if (velocity <= 42) return 3;
    if (velocity <= 84) return 4;
    return 6;
}

void LEDController::addSplash(uint8_t keyIndex, uint8_t velocity) {
    // Find inactive splash slot
    for (uint8_t i = 0; i < MAX_SPLASHES; i++) {
        if (!_splashes[i].active) {
            _splashes[i].active = true;
            _splashes[i].centerKey = keyIndex;
            _splashes[i].width = 1;  // Start with just center
            _splashes[i].maxWidth = velocityToSplashWidth(velocity);
            _splashes[i].brightness = 255;
            _splashes[i].hue = _hue;  // Use current hue setting
            break;
        }
    }
}

void LEDController::updateSplash() {
    for (uint8_t i = 0; i < MAX_SPLASHES; i++) {
        if (!_splashes[i].active) continue;

        SplashEffect& splash = _splashes[i];

        // Expand splash if not at max width
        if (splash.width < splash.maxWidth) {
            splash.width++;
        }

        // Fade brightness
        if (splash.brightness > 25) {
            splash.brightness -= 25;
        } else {
            splash.active = false;
            continue;
        }

        // Calculate center LED position
        uint16_t centerLED = splash.centerKey * LEDS_PER_KEY + LEDS_PER_KEY / 2;

        // Draw splash: center brightest, edges dimmer
        for (int8_t offset = -(int8_t)splash.width; offset <= (int8_t)splash.width; offset++) {
            int16_t ledIndex = centerLED + offset;
            if (ledIndex < 0 || ledIndex >= NUM_LEDS) continue;

            // Calculate brightness falloff from center
            uint8_t distance = abs(offset);
            uint8_t falloff = 255 - (distance * 255 / (splash.width + 1));
            uint8_t ledBrightness = (splash.brightness * falloff) / 255;

            CHSV color(splash.hue, 255, ledBrightness);

            // Additive blending: keep brighter value
            CRGB newColor = color;
            if (_leds[ledIndex].getLuma() < newColor.getLuma()) {
                _leds[ledIndex] = newColor;
            }
        }
    }
}

// ============== Hotkey Controls ==============

void LEDController::adjustBrightness(int16_t delta) {
    int16_t newBrightness = (int16_t)_brightness + delta;
    // Clamp to valid range
    if (newBrightness < 0) newBrightness = 0;
    if (newBrightness > 255) newBrightness = 255;
    setBrightness((uint8_t)newBrightness);
}

void LEDController::cycleMode() {
    // Cycle through main modes: Free Play -> Velocity -> Split -> Random -> Visualizer -> Ambient -> Kids Rainbow
    // Skip Learning and Demo modes (those are app-controlled)
    LEDMode modes[] = {MODE_FREE_PLAY, MODE_VELOCITY, MODE_SPLIT, MODE_RANDOM, MODE_VISUALIZER, MODE_AMBIENT, MODE_KIDS_RAINBOW};
    const int numModes = sizeof(modes) / sizeof(modes[0]);

    int currentIndex = 0;
    for (int i = 0; i < numModes; i++) {
        if (modes[i] == _mode) {
            currentIndex = i;
            break;
        }
    }

    int nextIndex = (currentIndex + 1) % numModes;
    setMode(modes[nextIndex]);
}

void LEDController::toggleEnabled() {
    _enabled = !_enabled;
    if (!_enabled) {
        blackout();
    }
}

bool LEDController::isEnabled() const {
    return _enabled;
}

// ============== Learning Mode ==============

void LEDController::setExpectedNotes(const uint8_t* notes, uint8_t count) {
    _expectedCount = min(count, MAX_EXPECTED_NOTES);
    for (uint8_t i = 0; i < _expectedCount; i++) {
        _expectedNotes[i] = notes[i];
    }
}

void LEDController::clearExpectedNotes() {
    _expectedCount = 0;
    memset(_expectedNotes, 0, sizeof(_expectedNotes));
}

void LEDController::setGuideColor(uint8_t hue, uint8_t sat, uint8_t val) {
    _guideColor = CHSV(hue, sat, val);
}

void LEDController::setSuccessColor(uint8_t hue, uint8_t sat, uint8_t val) {
    _successColor = CHSV(hue, sat, val);
}

void LEDController::setErrorColor(uint8_t hue, uint8_t sat, uint8_t val) {
    _errorColor = CHSV(hue, sat, val);
}

// ============== Background Layer ==============

void LEDController::setBackgroundEnabled(bool enabled) {
    _bgEnabled = enabled;
    if (!enabled) {
        // Fade to black when disabling background
        blackout();
    }
}

bool LEDController::isBackgroundEnabled() const {
    return _bgEnabled;
}

void LEDController::setBackgroundColor(uint8_t hue, uint8_t sat, uint8_t val) {
    _bgColor = CHSV(hue, sat, val);
}

void LEDController::setBackgroundBrightness(uint8_t brightness) {
    _bgBrightness = brightness;
}

// ============== Hue Shift / Chord Detection ==============

void LEDController::setHueShiftEnabled(bool enabled) {
    _hueShiftEnabled = enabled;
    if (enabled) {
        // Reset chord detection state
        _currentChordHue = _hue;
        _lastNoteTime = 0;
    }
}

bool LEDController::isHueShiftEnabled() const {
    return _hueShiftEnabled;
}

void LEDController::setHueShiftAmount(uint8_t amount) {
    _hueShiftAmount = amount;
}

void LEDController::setChordWindowMs(uint16_t windowMs) {
    _chordWindowMs = windowMs;
}

// ============== Ambient Animations ==============

void LEDController::setAmbientAnimation(uint8_t animation) {
    _ambientAnimation = animation % 3;  // 0, 1, or 2
    _animationOffset = 0;  // Reset animation state
}

uint8_t LEDController::getAmbientAnimation() const {
    return _ambientAnimation;
}

void LEDController::setAnimationSpeed(uint8_t speed) {
    _animationSpeed = max((uint8_t)1, speed);  // Minimum speed of 1
}

uint8_t LEDController::getAnimationSpeed() const {
    return _animationSpeed;
}

void LEDController::updateAmbient() {
    // Increment animation offset based on speed
    _animationOffset += _animationSpeed / 10;

    switch (_ambientAnimation) {
        case 0:
            animateRainbow();
            break;
        case 1:
            animateSineWave();
            break;
        case 2:
            animateSparkle();
            break;
        default:
            animateRainbow();
            break;
    }
}

void LEDController::animateRainbow() {
    // Moving rainbow across all LEDs
    for (uint16_t i = 0; i < NUM_LEDS; i++) {
        // Calculate hue based on position and animation offset
        uint8_t hue = (i * 256 / NUM_LEDS) + _animationOffset;
        _leds[i] = CHSV(hue, 255, 255);
    }
}

void LEDController::animateSineWave() {
    // Pulsing brightness wave across the strip
    for (uint16_t i = 0; i < NUM_LEDS; i++) {
        // Calculate phase for this LED
        uint8_t phase = (i * 256 / NUM_LEDS) + _animationOffset;
        // Use sine wave for brightness (sin8 returns 0-255)
        uint8_t brightness = sin8(phase);
        _leds[i] = CHSV(_hue, _saturation, brightness);
    }
}

void LEDController::animateSparkle() {
    // Fade all LEDs slightly first
    for (uint16_t i = 0; i < NUM_LEDS; i++) {
        _leds[i].fadeToBlackBy(30);
    }

    // Add random sparkles based on speed
    uint8_t numSparkles = _animationSpeed / 25 + 1;
    for (uint8_t s = 0; s < numSparkles; s++) {
        uint16_t pos = random(NUM_LEDS);
        // Random sparkle with current hue or white
        if (random(2) == 0) {
            _leds[pos] = CHSV(_hue, _saturation, 255);
        } else {
            _leds[pos] = CRGB::White;
        }
    }
}
