/**
 * Pianora Firmware v1.0.0
 * WiFi + OTA + BLE MIDI + USB MIDI Host + LED Controller
 * + Calibration + Recording + Demo Mode Hotkey
 * + Kids Rainbow Mode + Smart Defaults + Rainbow Startup Animation
 */

#include <Arduino.h>
#include <WiFi.h>
#include <WebServer.h>
#include <WebSocketsServer.h>
#include <DNSServer.h>
#include <ArduinoJson.h>
#include <LittleFS.h>
#include <ESPmDNS.h>
#include <Preferences.h>
#include <Update.h>
#include <ElegantOTA.h>
#include <NimBLEDevice.h>

#include "config.h"
#include "led_controller.h"
// Temporarily disable USB MIDI to test if it's causing boot crash
#define DISABLE_USB_MIDI_FOR_DEBUG 1

#if !DISABLE_USB_MIDI_FOR_DEBUG
#include "usb_midi.h"
#include "hotkey_handler.h"
#endif

// Constants
#define WIFI_CONNECT_TIMEOUT 15000
#define WIFI_RECONNECT_INTERVAL 30000
#define AP_SSID "Pianora"
#define AP_PASS "pianora123"
#define MDNS_NAME "pianora"
#ifndef FW_VERSION
#define FW_VERSION "1.0.0"
#endif

// BLE MIDI UUIDs
static NimBLEUUID MIDI_SERVICE_UUID("03b80e5a-ede8-4b33-a751-6ce34ec4c700");
static NimBLEUUID MIDI_CHAR_UUID("7772e5db-3868-4112-a1a9-f2669d106bf3");

// Objects
DNSServer dnsServer;
WebServer server(80);
WebSocketsServer webSocket(81);
Preferences preferences;

// WiFi State
enum PianoraWiFiMode { WIFI_MODE_AP_ONLY, WIFI_MODE_STA_ONLY, WIFI_MODE_AP_STA };
PianoraWiFiMode currentWiFiMode = WIFI_MODE_AP_ONLY;
bool staConnected = false;
String staSSID = "";
String staPassword = "";
String staIP = "";
uint32_t lastWiFiCheck = 0;

// BLE MIDI State
NimBLEScan* pBLEScan = nullptr;
NimBLEClient* pBLEClient = nullptr;
NimBLERemoteCharacteristic* pMidiCharacteristic = nullptr;
bool bleScanning = false;
bool bleConnected = false;
bool bleConnecting = false;  // Flag to track connection in progress
String bleMidiDeviceName = "";
NimBLEAddress bleMidiDeviceAddress;
bool bleAutoConnect = false;
std::vector<std::pair<String, NimBLEAddress>> foundBleDevices;
uint32_t bleScanStartTime = 0;
const uint32_t BLE_SCAN_DURATION = 20000; // 20 seconds in ms

// App State
uint8_t currentMode = 0;
uint8_t brightness = 128;
bool midiConnected = false;

// Calibration state
CalibrationState calibrationState = CALIB_IDLE;
CalibrationData calibrationData = {LOWEST_MIDI_NOTE, HIGHEST_MIDI_NOTE, 0, NUM_LEDS - 1, false};

// Recording state
RecordingState recording = {false, 0, 0, {}};

// Forward declarations
void loadWiFiSettings();
void saveWiFiSettings();
void setupWiFi();
void checkWiFiConnection();
void sendStatus(uint8_t clientNum);
void broadcastStatus();
void broadcastMidiNote(uint8_t note, uint8_t velocity, bool on);
void broadcastBleDevices();
void setupBLE();
void startBleScan();
void stopBleScan();
void connectToBleDevice(NimBLEAddress address);
void disconnectBle();

// USB MIDI callbacks
void onUsbMidiNoteOn(uint8_t channel, uint8_t note, uint8_t velocity);
void onUsbMidiNoteOff(uint8_t channel, uint8_t note, uint8_t velocity);
void onUsbMidiConnection(bool connected);

// Calibration functions
void loadCalibration();
void saveCalibration();
void processCalibrationNote(uint8_t note, uint8_t clientNum);
void sendCalibrationStep(uint8_t clientNum, const char* step, const char* message);

// Recording functions
void startRecording();
void stopRecording();
void recordNote(uint8_t note, uint8_t velocity);
void sendRecordingData(uint8_t clientNum);

// ============== WiFi Settings ==============

void loadWiFiSettings() {
    preferences.begin("pianora", true);
    staSSID = preferences.getString("wifi_ssid", "");
    staPassword = preferences.getString("wifi_pass", "");
    preferences.end();
}

void saveWiFiSettings() {
    preferences.begin("pianora", false);
    preferences.putString("wifi_ssid", staSSID);
    preferences.putString("wifi_pass", staPassword);
    preferences.end();
}

void clearWiFiSettings() {
    preferences.begin("pianora", false);
    preferences.remove("wifi_ssid");
    preferences.remove("wifi_pass");
    preferences.end();

    staSSID = "";
    staPassword = "";
}

// ============== Calibration ==============

void loadCalibration() {
    preferences.begin("pianora", true);
    calibrationData.firstNote = preferences.getUChar("cal_first_note", LOWEST_MIDI_NOTE);
    calibrationData.lastNote = preferences.getUChar("cal_last_note", HIGHEST_MIDI_NOTE);
    calibrationData.firstLed = preferences.getUChar("cal_first_led", 0);
    calibrationData.lastLed = preferences.getUChar("cal_last_led", NUM_LEDS - 1);
    calibrationData.calibrated = preferences.getBool("cal_done", false);
    preferences.end();
}

void saveCalibration() {
    preferences.begin("pianora", false);
    preferences.putUChar("cal_first_note", calibrationData.firstNote);
    preferences.putUChar("cal_last_note", calibrationData.lastNote);
    preferences.putUChar("cal_first_led", calibrationData.firstLed);
    preferences.putUChar("cal_last_led", calibrationData.lastLed);
    preferences.putBool("cal_done", true);
    preferences.end();
    calibrationData.calibrated = true;
}

void sendCalibrationStep(uint8_t clientNum, const char* step, const char* message) {
    JsonDocument doc;
    doc["type"] = "calibration_step";
    doc["step"] = step;
    doc["message"] = message;
    doc["first_note"] = calibrationData.firstNote;
    doc["last_note"] = calibrationData.lastNote;
    doc["calibrated"] = calibrationData.calibrated;

    String json;
    serializeJson(doc, json);
    webSocket.sendTXT(clientNum, json);
}

void processCalibrationNote(uint8_t note, uint8_t clientNum) {
    switch (calibrationState) {
        case CALIB_WAIT_FIRST_KEY:
            calibrationData.firstNote = note;
            calibrationData.firstLed = 0;
            calibrationState = CALIB_WAIT_LAST_KEY;

            // Visual feedback: green flash
            ledController->showColor(CRGB::Green);
            delay(200);
            ledController->blackout();

            sendCalibrationStep(clientNum, "wait_last", "Now press the highest key");
            break;

        case CALIB_WAIT_LAST_KEY:
            calibrationData.lastNote = note;
            calibrationData.lastLed = NUM_LEDS - 1;
            calibrationState = CALIB_IDLE;

            // Save calibration
            saveCalibration();

            // Visual feedback: green flash
            ledController->showColor(CRGB::Green);
            delay(500);
            ledController->blackout();

            sendCalibrationStep(clientNum, "complete", "Calibration complete");
            broadcastStatus();
            break;

        default:
            break;
    }
}

// ============== Recording ==============

void startRecording() {
    recording.isRecording = true;
    recording.startTime = millis();
    recording.noteCount = 0;
    memset(recording.notes, 0, sizeof(recording.notes));

    // Visual feedback: red flash
    ledController->showColor(CRGB::Red);
    delay(200);
    ledController->blackout();
}

void stopRecording() {
    recording.isRecording = false;

    // Visual feedback: green flash
    ledController->showColor(CRGB::Green);
    delay(200);
    ledController->blackout();
}

void recordNote(uint8_t note, uint8_t velocity) {
    if (!recording.isRecording) return;
    if (recording.noteCount >= MAX_RECORDING_NOTES) return;

    // Check timeout
    if (millis() - recording.startTime > RECORDING_TIMEOUT_MS) {
        stopRecording();
        return;
    }

    RecordedNote& rec = recording.notes[recording.noteCount];
    rec.timestamp = millis() - recording.startTime;
    rec.note = note;
    rec.velocity = velocity;
    recording.noteCount++;
}

void sendRecordingData(uint8_t clientNum) {
    const uint16_t CHUNK_SIZE = 50;  // Notes per message

    // Send metadata first
    JsonDocument metaDoc;
    metaDoc["type"] = "recording_data";
    metaDoc["total_notes"] = recording.noteCount;
    if (recording.noteCount > 0) {
        metaDoc["duration_ms"] = recording.notes[recording.noteCount - 1].timestamp;
    } else {
        metaDoc["duration_ms"] = 0;
    }
    metaDoc["total_chunks"] = (recording.noteCount + CHUNK_SIZE - 1) / CHUNK_SIZE;

    // Send data in chunks
    for (uint16_t chunk = 0; chunk * CHUNK_SIZE < recording.noteCount || chunk == 0; chunk++) {
        JsonDocument chunkDoc;
        chunkDoc["type"] = "recording_data";
        chunkDoc["chunk"] = chunk;
        chunkDoc["total_chunks"] = (recording.noteCount + CHUNK_SIZE - 1) / CHUNK_SIZE;

        if (chunk == 0) {
            chunkDoc["total_notes"] = recording.noteCount;
            chunkDoc["duration_ms"] = recording.noteCount > 0 ?
                recording.notes[recording.noteCount - 1].timestamp : 0;
        }

        JsonArray notes = chunkDoc["notes"].to<JsonArray>();
        uint16_t start = chunk * CHUNK_SIZE;
        uint16_t end = min((uint16_t)(start + CHUNK_SIZE), recording.noteCount);

        for (uint16_t i = start; i < end; i++) {
            JsonObject n = notes.add<JsonObject>();
            n["t"] = recording.notes[i].timestamp;
            n["n"] = recording.notes[i].note;
            n["v"] = recording.notes[i].velocity;
        }

        String json;
        serializeJson(chunkDoc, json);
        webSocket.sendTXT(clientNum, json);
    }
}

// ============== WiFi Setup ==============

void setupWiFi() {
    loadWiFiSettings();

    if (staSSID.length() > 0) {
        WiFi.mode(WIFI_AP_STA);
        WiFi.softAP(AP_SSID, AP_PASS);
        WiFi.begin(staSSID.c_str(), staPassword.c_str());

        uint32_t startTime = millis();
        while (WiFi.status() != WL_CONNECTED && millis() - startTime < WIFI_CONNECT_TIMEOUT) {
            delay(500);
        }

        if (WiFi.status() == WL_CONNECTED) {
            staConnected = true;
            staIP = WiFi.localIP().toString();
            currentWiFiMode = WIFI_MODE_AP_STA;
        } else {
            staConnected = false;
            currentWiFiMode = WIFI_MODE_AP_STA;
        }
    } else {
        WiFi.mode(WIFI_AP);
        WiFi.softAP(AP_SSID, AP_PASS);
        currentWiFiMode = WIFI_MODE_AP_ONLY;
    }

    if (MDNS.begin(MDNS_NAME)) {
        MDNS.addService("http", "tcp", 80);
        MDNS.addService("ws", "tcp", 81);
    }
}

void checkWiFiConnection() {
    if (staSSID.length() == 0) return;

    if (millis() - lastWiFiCheck < WIFI_RECONNECT_INTERVAL) return;
    lastWiFiCheck = millis();

    if (WiFi.status() != WL_CONNECTED) {
        if (staConnected) {
            staConnected = false;
            staIP = "";
            broadcastStatus();
        }
        WiFi.disconnect();
        WiFi.begin(staSSID.c_str(), staPassword.c_str());
    } else if (!staConnected) {
        staConnected = true;
        staIP = WiFi.localIP().toString();
        broadcastStatus();
    }
}

// ============== BLE MIDI ==============

// Callback for BLE MIDI notifications
// BLE MIDI packet format (Apple/MIDI BLE spec):
// [header] [timestamp] [status] [data1] [data2] [timestamp] [status] [data1] [data2] ...
// Header:    1ttttttt (bit 7 = 1, bits 0-6 = timestamp high)
// Timestamp: 1ttttttt (bit 7 = 1, bits 0-6 = timestamp low)
// Status:    1sssnnnn (bit 7 = 1, MIDI status byte 0x80-0xFF)
// Data:      0ddddddd (bit 7 = 0, data bytes 0x00-0x7F)
void midiNotifyCallback(NimBLERemoteCharacteristic* pChar, uint8_t* pData, size_t length, bool isNotify) {
    if (length < 3) return;

    static uint8_t runningStatus = 0;
    size_t i = 1;

    while (i < length) {
        uint8_t byte = pData[i];

        if (byte & 0x80) {
            uint8_t type = byte & 0xF0;
            if ((type == 0x80 || type == 0x90) && (i + 2 < length)) {
                if ((pData[i + 1] & 0x80) == 0 && (pData[i + 2] & 0x80) == 0) {
                    runningStatus = byte;
                    uint8_t note = pData[i + 1] & 0x7F;
                    uint8_t velocity = pData[i + 2] & 0x7F;

                    if (type == 0x90 && velocity > 0) {
                        // Record note if recording
                        if (recording.isRecording) {
                            recordNote(note, velocity);
                        }
                        // Process calibration if active
                        if (calibrationState != CALIB_IDLE) {
                            processCalibrationNote(note, 0);
                        } else {
                            ledController->noteOn(note, velocity);
                            broadcastMidiNote(note, velocity, true);
                        }
                    } else {
                        // Record note off if recording
                        if (recording.isRecording) {
                            recordNote(note, 0);
                        }
                        ledController->noteOff(note);
                        broadcastMidiNote(note, 0, false);
                    }
                    i += 3;
                    continue;
                }
            }
            i++;
            continue;
        }

        if (runningStatus && (i + 1 < length) && ((pData[i + 1] & 0x80) == 0)) {
            uint8_t type = runningStatus & 0xF0;
            uint8_t note = byte & 0x7F;
            uint8_t velocity = pData[i + 1] & 0x7F;

            if (type == 0x90 && velocity > 0) {
                // Record note if recording
                if (recording.isRecording) {
                    recordNote(note, velocity);
                }
                // Process calibration if active
                if (calibrationState != CALIB_IDLE) {
                    processCalibrationNote(note, 0);
                } else {
                    ledController->noteOn(note, velocity);
                    broadcastMidiNote(note, velocity, true);
                }
            } else if (type == 0x80 || (type == 0x90 && velocity == 0)) {
                // Record note off if recording
                if (recording.isRecording) {
                    recordNote(note, 0);
                }
                ledController->noteOff(note);
                broadcastMidiNote(note, 0, false);
            }
            i += 2;
        } else {
            i++;
        }
    }
}

// Client callbacks
class BleClientCallbacks : public NimBLEClientCallbacks {
    void onConnect(NimBLEClient* pClient) override {
    }

    void onDisconnect(NimBLEClient* pClient, int reason) override {
        if (!bleConnecting) {
            bleConnected = false;
            midiConnected = false;
            broadcastStatus();
        }
    }
};

static BleClientCallbacks* clientCallbacks = nullptr;

// Scan callbacks
class BleScanCallbacks : public NimBLEScanCallbacks {
    void onResult(const NimBLEAdvertisedDevice* advertisedDevice) override {
        String name = advertisedDevice->getName().c_str();
        String addr = advertisedDevice->getAddress().toString().c_str();

        bool isMidiDevice = advertisedDevice->isAdvertisingService(MIDI_SERVICE_UUID);

        bool isKnownBrand = false;
        if (name.length() > 0) {
            isKnownBrand = (name.indexOf("Kawai") >= 0 ||
                            name.indexOf("KDP") >= 0 ||
                            name.indexOf("Roland") >= 0 ||
                            name.indexOf("Yamaha") >= 0 ||
                            name.indexOf("Piano") >= 0 ||
                            name.indexOf("MIDI") >= 0 ||
                            name.indexOf("Casio") >= 0 ||
                            name.indexOf("Korg") >= 0 ||
                            name.indexOf("Nord") >= 0 ||
                            name.indexOf("CN") >= 0 ||
                            name.indexOf("CA") >= 0 ||
                            name.indexOf("ES") >= 0);
        }

        if (isMidiDevice || isKnownBrand) {
            String displayName = name.length() > 0 ? name : addr;

            bool exists = false;
            for (auto& dev : foundBleDevices) {
                if (dev.second == advertisedDevice->getAddress()) {
                    exists = true;
                    break;
                }
            }
            if (!exists) {
                foundBleDevices.push_back({displayName, advertisedDevice->getAddress()});
            }
        }
    }

    void onScanEnd(const NimBLEScanResults& results, int reason) override {
        bleScanning = false;
        bleScanStartTime = 0;
        broadcastBleDevices();
        broadcastStatus();
    }
};

static BleScanCallbacks* scanCallbacks = nullptr;

void setupBLE() {
    // Create BLE callback objects (lazy initialization)
    clientCallbacks = new BleClientCallbacks();
    scanCallbacks = new BleScanCallbacks();

    NimBLEDevice::init("Pianora");
    NimBLEDevice::setPower(ESP_PWR_LVL_P9);

    pBLEScan = NimBLEDevice::getScan();
    pBLEScan->setScanCallbacks(scanCallbacks);
    pBLEScan->setInterval(160);
    pBLEScan->setWindow(40);
    pBLEScan->setActiveScan(true);
    pBLEScan->setDuplicateFilter(true);
}

void startBleScan() {
    if (bleScanning) return;

    foundBleDevices.clear();
    bleScanning = true;

    pBLEScan->clearResults();

    bool started = pBLEScan->start(0, false, true);

    if (!started) {
        bleScanning = false;
        bleScanStartTime = 0;
    } else {
        bleScanStartTime = millis();
    }
}

void stopBleScan() {
    if (!bleScanning) return;
    pBLEScan->stop();
    bleScanning = false;
}

void connectToBleDevice(NimBLEAddress address) {
    bleConnecting = true;
    pMidiCharacteristic = nullptr;

    if (bleScanning || pBLEScan->isScanning()) {
        pBLEScan->stop();
        bleScanning = false;
        bleScanStartTime = 0;
        delay(500);
    }

    WiFi.setTxPower(WIFI_POWER_MINUS_1dBm);
    delay(200);

    if (pBLEClient != nullptr) {
        if (pBLEClient->isConnected()) {
            pBLEClient->disconnect();
            delay(300);
        }
    } else {
        pBLEClient = NimBLEDevice::createClient();
    }

    if (pBLEClient == nullptr) {
        WiFi.setTxPower(WIFI_POWER_19_5dBm);
        bleConnecting = false;
        broadcastStatus();
        return;
    }
    pBLEClient->setClientCallbacks(clientCallbacks);
    pBLEClient->setConnectionParams(12, 24, 0, 400);
    pBLEClient->setConnectTimeout(10);

    bool connected = pBLEClient->connect(address);

    WiFi.setTxPower(WIFI_POWER_19_5dBm);

    if (!connected) {
        bleConnected = false;
        bleConnecting = false;
        broadcastStatus();
        return;
    }

    NimBLERemoteService* pService = pBLEClient->getService(MIDI_SERVICE_UUID);
    if (pService == nullptr) {
        pBLEClient->disconnect();
        bleConnected = false;
        bleConnecting = false;
        broadcastStatus();
        return;
    }

    pMidiCharacteristic = pService->getCharacteristic(MIDI_CHAR_UUID);
    if (pMidiCharacteristic == nullptr) {
        pBLEClient->disconnect();
        bleConnected = false;
        bleConnecting = false;
        broadcastStatus();
        return;
    }

    if (pMidiCharacteristic->canNotify()) {
        pMidiCharacteristic->subscribe(true, midiNotifyCallback);
    }

    bleConnected = true;
    bleConnecting = false;
    midiConnected = true;
    bleMidiDeviceAddress = address;

    for (auto& dev : foundBleDevices) {
        if (dev.second == address) {
            bleMidiDeviceName = dev.first;
            break;
        }
    }

    broadcastStatus();
}

void disconnectBle() {
    bleConnecting = true;

    if (pBLEClient != nullptr && pBLEClient->isConnected()) {
        pBLEClient->disconnect();
    }

    pMidiCharacteristic = nullptr;
    bleConnected = false;
    bleConnecting = false;
    midiConnected = false;
    bleMidiDeviceName = "";
    broadcastStatus();
}

// ============== MIME Types ==============

String getContentType(String filename) {
    if (filename.endsWith(".html")) return "text/html";
    if (filename.endsWith(".css")) return "text/css";
    if (filename.endsWith(".js")) return "application/javascript";
    if (filename.endsWith(".json")) return "application/json";
    if (filename.endsWith(".png")) return "image/png";
    if (filename.endsWith(".ico")) return "image/x-icon";
    if (filename.endsWith(".svg")) return "image/svg+xml";
    if (filename.endsWith(".webmanifest")) return "application/manifest+json";
    return "text/plain";
}

// ============== File Server ==============

bool handleFileRead(String path) {
    if (path.endsWith("/")) path += "index.html";

    String contentType = getContentType(path);

    if (LittleFS.exists(path)) {
        File file = LittleFS.open(path, "r");
        server.streamFile(file, contentType);
        file.close();
        return true;
    }

    // SPA fallback
    if (LittleFS.exists("/index.html")) {
        File file = LittleFS.open("/index.html", "r");
        server.streamFile(file, "text/html");
        file.close();
        return true;
    }

    return false;
}

// ============== WebSocket ==============

void sendStatus(uint8_t clientNum) {
    JsonDocument doc;
    doc["type"] = "status";
    doc["version"] = FW_VERSION;
#if !DISABLE_USB_MIDI_FOR_DEBUG
    doc["midi_connected"] = midiConnected || usbMidi->isConnected();
    doc["usb_midi_connected"] = usbMidi->isConnected();
#else
    doc["midi_connected"] = midiConnected;
    doc["usb_midi_connected"] = false;
#endif
    doc["ble_connected"] = bleConnected;
    doc["ble_scanning"] = bleScanning;
    doc["ble_device_name"] = bleMidiDeviceName;
    doc["mode"] = currentMode;
    doc["brightness"] = brightness;
    doc["led_mode"] = (int)ledController->getMode();
    doc["led_hue"] = ledController->getHue();
    doc["ambient_animation"] = ledController->getAmbientAnimation();
    doc["animation_speed"] = ledController->getAnimationSpeed();
    doc["calibrated"] = calibrationData.calibrated;
    doc["cal_first_note"] = calibrationData.firstNote;
    doc["cal_last_note"] = calibrationData.lastNote;
    doc["is_recording"] = recording.isRecording;
    doc["recording_notes"] = recording.noteCount;
    doc["ws_clients"] = webSocket.connectedClients();
    doc["free_heap"] = ESP.getFreeHeap();

    JsonObject wifi = doc["wifi"].to<JsonObject>();
    wifi["mode"] = currentWiFiMode == WIFI_MODE_AP_ONLY ? "ap" : (currentWiFiMode == WIFI_MODE_STA_ONLY ? "sta" : "ap_sta");
    wifi["apIp"] = WiFi.softAPIP().toString();
    wifi["apSSID"] = AP_SSID;
    wifi["staConnected"] = staConnected;
    wifi["staSSID"] = staSSID;
    wifi["staIP"] = staIP;
    wifi["rssi"] = staConnected ? WiFi.RSSI() : 0;

    JsonObject features = doc["features"].to<JsonObject>();
    features["elegant_ota"] = true;
    features["ble_midi"] = true;
    features["usb_midi"] = true;
    features["wifi_sta"] = true;
    features["led_strip"] = true;

    String json;
    serializeJson(doc, json);
    webSocket.sendTXT(clientNum, json);
}

void broadcastStatus() {
    for (uint8_t i = 0; i < webSocket.connectedClients(); i++) {
        sendStatus(i);
    }
}

void broadcastMidiNote(uint8_t note, uint8_t velocity, bool on) {
    JsonDocument doc;
    doc["type"] = "midi_note";
    doc["note"] = note;
    doc["velocity"] = velocity;
    doc["on"] = on;

    String json;
    serializeJson(doc, json);

    if (webSocket.connectedClients() > 0) {
        webSocket.broadcastTXT(json);
    }
}

// Callback for play/pause hotkey - broadcasts to app
void onHotkeyPlayPause() {
    JsonDocument doc;
    doc["type"] = "hotkey";
    doc["action"] = "play_pause";

    String json;
    serializeJson(doc, json);

    if (webSocket.connectedClients() > 0) {
        webSocket.broadcastTXT(json);
    }
}

void sendBleDevices(uint8_t clientNum) {
    JsonDocument doc;
    doc["type"] = "ble_devices";

    JsonArray devices = doc["devices"].to<JsonArray>();
    for (auto& dev : foundBleDevices) {
        JsonObject device = devices.add<JsonObject>();
        device["name"] = dev.first;
        device["address"] = dev.second.toString();
    }

    String json;
    serializeJson(doc, json);
    webSocket.sendTXT(clientNum, json);
}

void broadcastBleDevices() {
    JsonDocument doc;
    doc["type"] = "ble_devices";

    JsonArray devices = doc["devices"].to<JsonArray>();
    for (auto& dev : foundBleDevices) {
        JsonObject device = devices.add<JsonObject>();
        device["name"] = dev.first;
        device["address"] = dev.second.toString();
    }

    String json;
    serializeJson(doc, json);
    webSocket.broadcastTXT(json);
}

void sendWiFiNetworks(uint8_t clientNum) {
    JsonDocument doc;
    doc["type"] = "wifi_networks";

    JsonArray networks = doc["payload"].to<JsonArray>();

    int n = WiFi.scanNetworks();
    for (int i = 0; i < n && i < 20; i++) {
        JsonObject net = networks.add<JsonObject>();
        net["ssid"] = WiFi.SSID(i);
        net["rssi"] = WiFi.RSSI(i);
        net["secure"] = WiFi.encryptionType(i) != WIFI_AUTH_OPEN;
    }
    WiFi.scanDelete();

    String json;
    serializeJson(doc, json);
    webSocket.sendTXT(clientNum, json);
}

void sendWiFiStatus(uint8_t clientNum, bool success, const char* message) {
    JsonDocument doc;
    doc["type"] = "wifi_status";
    doc["payload"]["success"] = success;
    doc["payload"]["message"] = message;
    doc["payload"]["connected"] = staConnected;
    doc["payload"]["ip"] = staIP;

    String json;
    serializeJson(doc, json);
    webSocket.sendTXT(clientNum, json);
}

void webSocketEvent(uint8_t num, WStype_t type, uint8_t *payload, size_t length) {
    switch (type) {
        case WStype_DISCONNECTED:
            break;

        case WStype_CONNECTED:
            sendStatus(num);
            break;

        case WStype_TEXT: {
            JsonDocument doc;
            DeserializationError error = deserializeJson(doc, payload, length);
            if (error) return;

            const char* msgType = doc["type"];
            if (!msgType) return;

            if (strcmp(msgType, "get_status") == 0) {
                sendStatus(num);
            }
            else if (strcmp(msgType, "set_mode") == 0) {
                currentMode = doc["payload"]["mode"] | 0;
                ledController->setMode((LEDMode)currentMode);
                broadcastStatus();
            }
            else if (strcmp(msgType, "set_settings") == 0) {
                JsonObject settings = doc["payload"];
                if (settings.containsKey("brightness")) {
                    brightness = settings["brightness"];
                    ledController->setBrightness(brightness);
                }
                if (settings.containsKey("hue")) {
                    ledController->setHue(settings["hue"]);
                }
                broadcastStatus();
            }
            else if (strcmp(msgType, "set_expected_notes") == 0) {
                // Learning mode: set expected notes to highlight
                JsonArray notes = doc["payload"]["notes"];
                if (notes) {
                    uint8_t noteArray[10];
                    uint8_t count = min((size_t)notes.size(), (size_t)10);
                    for (size_t i = 0; i < count; i++) {
                        noteArray[i] = notes[i].as<uint8_t>();
                    }
                    ledController->setExpectedNotes(noteArray, count);
                } else {
                    ledController->clearExpectedNotes();
                }
            }
            else if (strcmp(msgType, "set_background") == 0) {
                // Background layer settings
                JsonObject payload = doc["payload"];
                if (payload.containsKey("enabled")) {
                    ledController->setBackgroundEnabled(payload["enabled"].as<bool>());
                }
                if (payload.containsKey("hue") && payload.containsKey("saturation")) {
                    uint8_t hue = payload["hue"];
                    uint8_t sat = payload["saturation"];
                    uint8_t val = payload.containsKey("brightness") ? payload["brightness"].as<uint8_t>() : 32;
                    ledController->setBackgroundColor(hue, sat, val);
                    ledController->setBackgroundBrightness(val);
                }
                broadcastStatus();
            }
            else if (strcmp(msgType, "set_hue_shift") == 0) {
                // Hue shift / chord detection settings
                JsonObject payload = doc["payload"];
                if (payload.containsKey("enabled")) {
                    ledController->setHueShiftEnabled(payload["enabled"].as<bool>());
                }
                if (payload.containsKey("amount")) {
                    ledController->setHueShiftAmount(payload["amount"].as<uint8_t>());
                }
                if (payload.containsKey("window_ms")) {
                    ledController->setChordWindowMs(payload["window_ms"].as<uint16_t>());
                }
                broadcastStatus();
            }
            else if (strcmp(msgType, "set_split") == 0) {
                // Split mode settings
                JsonObject payload = doc["payload"];
                if (payload.containsKey("splitPoint")) {
                    ledController->setSplitPosition(payload["splitPoint"].as<uint8_t>());
                }
                if (payload.containsKey("leftHue")) {
                    uint8_t hue = payload["leftHue"].as<uint8_t>();
                    uint8_t sat = payload.containsKey("leftSat") ? payload["leftSat"].as<uint8_t>() : 255;
                    ledController->setLeftColor(hue, sat, 255);
                }
                if (payload.containsKey("rightHue")) {
                    uint8_t hue = payload["rightHue"].as<uint8_t>();
                    uint8_t sat = payload.containsKey("rightSat") ? payload["rightSat"].as<uint8_t>() : 255;
                    ledController->setRightColor(hue, sat, 255);
                }
                broadcastStatus();
            }
            else if (strcmp(msgType, "set_ambient") == 0) {
                // Ambient animation settings
                JsonObject payload = doc["payload"];
                if (payload.containsKey("animation")) {
                    ledController->setAmbientAnimation(payload["animation"].as<uint8_t>());
                }
                if (payload.containsKey("speed")) {
                    ledController->setAnimationSpeed(payload["speed"].as<uint8_t>());
                }
                // Also set mode to ambient if specified
                if (payload.containsKey("enabled") && payload["enabled"].as<bool>()) {
                    ledController->setMode(MODE_AMBIENT);
                    currentMode = MODE_AMBIENT;
                }
                broadcastStatus();
            }
            else if (strcmp(msgType, "wifi_scan") == 0) {
                sendWiFiNetworks(num);
            }
            else if (strcmp(msgType, "wifi_connect") == 0) {
                const char* ssid = doc["payload"]["ssid"];
                const char* password = doc["payload"]["password"];

                if (ssid && strlen(ssid) > 0) {
                    staSSID = String(ssid);
                    staPassword = String(password ? password : "");
                    saveWiFiSettings();

                    WiFi.disconnect();
                    if (currentWiFiMode == WIFI_MODE_AP_ONLY) {
                        WiFi.mode(WIFI_AP_STA);
                        WiFi.softAP(AP_SSID, AP_PASS);
                        currentWiFiMode = WIFI_MODE_AP_STA;
                    }
                    WiFi.begin(staSSID.c_str(), staPassword.c_str());

                    uint32_t startTime = millis();
                    while (WiFi.status() != WL_CONNECTED && millis() - startTime < WIFI_CONNECT_TIMEOUT) {
                        delay(500);
                    }

                    if (WiFi.status() == WL_CONNECTED) {
                        staConnected = true;
                        staIP = WiFi.localIP().toString();
                        sendWiFiStatus(num, true, "Connected successfully");
                    } else {
                        staConnected = false;
                        staIP = "";
                        sendWiFiStatus(num, false, "Connection failed");
                    }
                    broadcastStatus();
                }
            }
            else if (strcmp(msgType, "wifi_disconnect") == 0) {
                clearWiFiSettings();
                WiFi.disconnect();
                staConnected = false;
                staIP = "";
                sendWiFiStatus(num, true, "Disconnected");
                broadcastStatus();
            }
            else if (strcmp(msgType, "scan_ble_midi") == 0) {
                startBleScan();
                broadcastStatus();
            }
            else if (strcmp(msgType, "stop_ble_scan") == 0) {
                stopBleScan();
                broadcastStatus();
            }
            else if (strcmp(msgType, "get_ble_devices") == 0) {
                sendBleDevices(num);
            }
            else if (strcmp(msgType, "connect_ble_midi") == 0) {
                const char* address = doc["payload"]["address"];
                if (address && strlen(address) > 0) {
                    bool found = false;
                    for (auto& dev : foundBleDevices) {
                        if (dev.second.toString() == std::string(address)) {
                            connectToBleDevice(dev.second);
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        NimBLEAddress addr(std::string(address), 1);
                        connectToBleDevice(addr);
                    }
                }
            }
            else if (strcmp(msgType, "disconnect_ble_midi") == 0) {
                disconnectBle();
            }
            else if (strcmp(msgType, "restart") == 0) {
                JsonDocument response;
                response["type"] = "restart";
                response["payload"]["success"] = true;
                String json;
                serializeJson(response, json);
                webSocket.sendTXT(num, json);
                delay(500);
                ESP.restart();
            }
            else if (strcmp(msgType, "start_calibration") == 0) {
                // Start calibration process
                calibrationState = CALIB_WAIT_FIRST_KEY;
                calibrationData.calibrated = false;

                // Visual feedback: yellow pulse
                ledController->showColor(CRGB::Yellow);
                delay(200);
                ledController->blackout();

                sendCalibrationStep(num, "wait_first", "Press the lowest key on your piano");
                broadcastStatus();
            }
            else if (strcmp(msgType, "calibration_input") == 0) {
                // Manual calibration input (for testing without MIDI)
                uint8_t note = doc["payload"]["note"] | 0;
                if (note >= LOWEST_MIDI_NOTE && note <= HIGHEST_MIDI_NOTE) {
                    processCalibrationNote(note, num);
                }
            }
            else if (strcmp(msgType, "cancel_calibration") == 0) {
                // Cancel calibration
                calibrationState = CALIB_IDLE;
                ledController->blackout();
                sendCalibrationStep(num, "cancelled", "Calibration cancelled");
                broadcastStatus();
            }
            else if (strcmp(msgType, "start_recording") == 0) {
                startRecording();
                broadcastStatus();
            }
            else if (strcmp(msgType, "stop_recording") == 0) {
                stopRecording();
                sendRecordingData(num);
                broadcastStatus();
            }
            break;
        }

        default:
            break;
    }
}

// ============== USB MIDI Callbacks ==============
#if !DISABLE_USB_MIDI_FOR_DEBUG
void onUsbMidiNoteOn(uint8_t channel, uint8_t note, uint8_t velocity) {
    // Record note if recording is active
    if (recording.isRecording) {
        recordNote(note, velocity);
    }

    // Process calibration if in calibration mode
    if (calibrationState != CALIB_IDLE) {
        processCalibrationNote(note, 0);  // clientNum 0 for broadcast
        return;  // Don't process as normal note during calibration
    }

    // Track note for hotkey detection
    hotkeyHandler->noteOn(note, velocity);

    // Check if hotkey was triggered
    if (hotkeyHandler->checkHotkey()) {
        return;  // Hotkey activated, don't process as normal note
    }

    // If this is an activation note (A1 or B1), still track but don't light up
    // This prevents the activation keys from lighting while waiting for action key
    if (hotkeyHandler->isActivationNote(note)) {
        broadcastMidiNote(note, velocity, true);
        return;
    }

    ledController->noteOn(note, velocity);
    broadcastMidiNote(note, velocity, true);
}

void onUsbMidiNoteOff(uint8_t channel, uint8_t note, uint8_t velocity) {
    // Record note off if recording is active
    if (recording.isRecording) {
        recordNote(note, 0);  // velocity 0 = note off
    }

    hotkeyHandler->noteOff(note);
    ledController->noteOff(note);
    broadcastMidiNote(note, 0, false);
}

void onUsbMidiConnection(bool connected) {
    midiConnected = connected;

    if (connected) {
        // Plug-and-Play: Auto-configure for immediate use
        // Uses smart defaults - works immediately without any configuration
        ledController->setMode(MODE_FREE_PLAY);
        ledController->setBrightness(DEFAULT_BRIGHTNESS);  // 50% - safe for eyes
        ledController->setHue(0);         // White - neutral, works with any setup
        ledController->setSaturation(0);  // No saturation = white light
        ledController->setSplashEnabled(false);  // Default to point mode (minimal latency)

        // Update global state
        currentMode = MODE_FREE_PLAY;
        brightness = DEFAULT_BRIGHTNESS;

        // Visual confirmation: brief white flash (matches default color)
        ledController->showColor(CRGB::White);
        delay(200);
        ledController->blackout();
    }

    broadcastStatus();
}
#endif // !DISABLE_USB_MIDI_FOR_DEBUG

// ============== Setup ==============

void setup() {
    Serial.begin(115200);
    delay(2000);  // Longer delay to ensure serial is ready
    Serial.println("\n\n=== PIANORA BOOT ===");
    Serial.println("If you see this, basic boot works!");
    Serial.flush();

    // Initialize global objects (lazy initialization to avoid static init issues)
    Serial.println("0. Creating objects...");
    Serial.flush();
    ledController = new LEDController();
#if !DISABLE_USB_MIDI_FOR_DEBUG
    usbMidi = new USBMidiHost();
    hotkeyHandler = new HotkeyHandler();
#endif
    Serial.println("   Objects created OK");
    Serial.flush();

    // Test each component one by one
    Serial.println("1. Testing LittleFS...");
    Serial.flush();
    LittleFS.begin(true);
    Serial.println("   LittleFS OK");
    Serial.flush();

    Serial.println("2. Testing NVS/Preferences...");
    Serial.flush();
    loadCalibration();
    Serial.println("   NVS OK");
    Serial.flush();

    Serial.println("3. Testing LED controller...");
    Serial.flush();
    ledController->begin();
    ledController->setMode(MODE_FREE_PLAY);
    Serial.println("   LED OK");
    Serial.flush();

#if !DISABLE_USB_MIDI_FOR_DEBUG
    Serial.println("4. Testing USB MIDI...");
    Serial.flush();
    usbMidi->begin();
    usbMidi->setNoteOnCallback(onUsbMidiNoteOn);
    usbMidi->setNoteOffCallback(onUsbMidiNoteOff);
    usbMidi->setConnectionCallback(onUsbMidiConnection);
#else
    Serial.println("4. USB MIDI DISABLED for debug");
    Serial.flush();
#endif

    // WiFi
    setupWiFi();

    // BLE
    setupBLE();

    // DNS (for captive portal in AP mode)
    dnsServer.start(53, "*", WiFi.softAPIP());

    // WebServer - Captive portal handlers
    server.on("/generate_204", []() {
        server.sendHeader("Location", "/", true);
        server.send(302, "text/plain", "");
    });
    server.on("/hotspot-detect.html", []() {
        server.sendHeader("Location", "/", true);
        server.send(302, "text/plain", "");
    });
    server.on("/connecttest.txt", []() {
        server.sendHeader("Location", "/", true);
        server.send(302, "text/plain", "");
    });

    // Serve files from LittleFS
    server.onNotFound([]() {
        if (!handleFileRead(server.uri())) {
            server.send(404, "text/plain", "File not found");
        }
    });

    // ElegantOTA
    ElegantOTA.begin(&server);

    server.begin();

    // WebSocket
    webSocket.begin();
    webSocket.onEvent(webSocketEvent);

    // Startup animation already played, no need for additional flash
}

// ============== Loop ==============

uint32_t lastStatusBroadcast = 0;

void loop() {
#if !DISABLE_USB_MIDI_FOR_DEBUG
    // USB MIDI Host task (must be called frequently)
    usbMidi->task();
#endif

    // LED Controller update (fading/animations)
    ledController->update();

    // Network tasks
    dnsServer.processNextRequest();
    server.handleClient();
    webSocket.loop();
    ElegantOTA.loop();

    // Check WiFi connection
    checkWiFiConnection();

    // Status broadcast every 5 seconds
    if (millis() - lastStatusBroadcast >= 5000) {
        lastStatusBroadcast = millis();
        if (webSocket.connectedClients() > 0) {
            broadcastStatus();
        }
    }

    // Check BLE scan timeout
    if (bleScanning && bleScanStartTime > 0) {
        if (millis() - bleScanStartTime >= BLE_SCAN_DURATION) {
            bleScanStartTime = 0;
            pBLEScan->stop();
            bleScanning = false;
            broadcastBleDevices();
            broadcastStatus();
        }
    }
}
